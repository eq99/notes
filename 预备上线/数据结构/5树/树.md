## 概念

 在树(tree)形结构中，每个结点有多个后继结点(succeeding node, succeesor)或称子结点(child, children)，但有且仅有一个前驱结点(precursor)或父结点(parent)，唯一的例外是根节点(root)没有父节点。那么如下概念就很明晰了：

- 根（root）：谁是根呢？那个没有父结点，从石头里蹦出来的结点就是根了。
- 兄弟结点(sibling)：拥有相同父结点的结点互称兄弟结点，这与家谱血缘关系相似。
- 祖先（ancestor）与子孙(descendant)：祖先：父结点，父父结点，父父父...结点；子孙节点：子节点，子子...节点。
- 叶子(leaf)节点：不是所有结点都有子节点，没有子节点的叫叶子节点。
- 结点的度(degree)：就是该节点拥有的子节点个数。
- 路径(path)：某个结点沿着父结点的父结点的$\dots$父结点到根，这个过程经历了一系列结点。那么这些结点组成了“某个结点”到根结点的一条路径。你可以反过来，从根到“某个结点”这样看，你可想象一下顺藤摸瓜，"藤"就是这里所说的"路径"。由于每个结点的父结点唯一，那么到根节点的路径也唯一。路径长度就是这一系列结点的个数，不算自己。你还可以求任意两个结点的路径，把他们联系在一起的是他们共同的祖先。
- 森林（forest）：独木不成林，树的集合叫森林。
- 树的深度（depth): 可以用家谱的**代**来理解树的深度，你是你家族第几代人，就处在家族树为几的深度，看到那个英文了吧，以th结尾，自带**第**的属性。计算方式嘛也很简单，就是叶子节点到根的路径长度，由于深度是树的属性，谁能代表整个树的深度呢，肯定就是那个路径最长的叶子结点了，代表家族兴旺。由于根到自己的路径长度为0，所以深度为0，根的子结点距离根一步之遥，所以深度为1。如何计算树的深度呢？$depth(tree)=max(depth(tree.children))+1$
- 有序数：子树按一定的次序从左向右排列。
- 树的变种：
    - 二叉树：由空结点或者由一个根节点和称为左子树和一个称为右子树的二叉树构成。

##  树计算

1. 树的结点树等于所有结点的度之和再加一。相当于把所有结点的子结点算进去，再把根也算进去。

## 树的表示

1. 跟踪父结点：每个结点除了保存数据还需要保存父结点的指针。特点：寻找父结点简单，寻找子结点难。

```c++
struct node {
  data_t data;
  struct node *parent;
}
```

2. 跟踪子结点：每个结点除了保存数据还需要保存所有子结点的指针。特点：寻找子结点简单，寻找父结点难。

```c++
struct node {
  data_t data;
  struct node *children[MAX_CHILDREN_NUM]; // note: pointer of array
}
```



3. 兄弟链：一个指针指向最左边的孩子，一个指针指向他的下一个兄弟。特点实现普通树与二叉树的互转，缺点是寻找父结点难。

```c++
struct node {
  data_t data;
  struct node *child;
  struct node *sibling;
}
```

提示：

1. 可以根据自己的需要存储指针。孩子结点父亲结点，兄弟结点都存上，不是说非得选哪个。
2. 进程在linux中是用树表示的，Linus Torvalds用的什么结构呢？

## 二叉树

### 概念

1.  与度为二的树（2次树）的区别：2次树至少需要一个度为二的结点，二叉树没有这种要求；2次树不区分左右子树，而二叉树严格区分左右子树。
2.  完全二叉树：只允许最后两层结点度数小于2，而且最下面一层结点从左到右依次排列，看起就像右下角有个小缺口。
3.  满二叉树：只有度为0和2的结点，而且叶子结点全在最后一层。右下角的缺口都没有了。
4.  几乎完全二叉树：
5.  对于完全二叉树：编号为$i$的结点，其父结点编号为$\lfloor i/2 \rfloor $, 如果有左结点，则其编号为$2i$，如果有右结点，则其编号为$2i+1$。

### 普通树，森林与二叉树互转

 普通树转二叉树：

- 讲所有兄弟结点间连一条线
- 除了第一个子节点，删除父结点其他子节点的连线

还原：

- 某个结点的右孩子，右右孩子，右...右孩子是他的兄弟结点，他们与**某个结点**有共同的父亲结点。
- 因此，从最右的子节点开始断绝关系，把他们依次连接到**某个结点**的父结点即可。

森林转为二叉树

- 把森林中的每棵树转为二叉树
- 把后一棵树的根节点作为前一棵树的右子节点连起来

还原：

- 由于根没有父结点，因此与**某个结点**有没共同的父亲结点自立为树，形成森林。

### 二叉树的存储

1. 如果使用线性表（数组）表示完全二叉树，可以用以下性质：

> 编号为$i$的结点，其父结点编号为$\lfloor i/2 \rfloor $, 如果有左子结点，则其编号为$2i$，如果有右子结点，则其编号为$2i+1$。

这里有个细节需要注意：这里的编号是从1开始的，如果从0开始，那么左孩子为$2i+1$，右孩子为$2i+$2，你可以自己验证。编程的时候，数组第一个下标是0，你可以不用，也可以用另外一个关系式。

2. 如果用数组表示一般的二叉树，中间有结点缺失，那么可以用一些特殊符号表示空结点，把他补成一个完全二叉树。

3. 用链表表示。

用链表这就简单了。还记得前面我们记录子节点的表示方法吧，只需设置`MAX_CHILDREN_NUM=2`即可，然后用children[0]表示左结点，children[1]表示右结点，你也可以把数组拆成两个域left, right

```c++
struct node {
  data_t data;
  struct node *children[2]; 
}

// or like this
struct node {
  data_t data;
  struct node *left;
  struct node *right;
}

// or even add parent
struct node {
  data_t data;
  struct node *left;
  struct node *right;
  struct node *parent;
}
```

